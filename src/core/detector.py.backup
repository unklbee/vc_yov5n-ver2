"""
src/core/detector.py - Robust version with OpenCV error handling
"""

import cv2
import numpy as np
import time
import os
from collections import deque, defaultdict
from typing import List, Dict, Tuple, Optional

# Simple tracker classes
class SimpleTracker:
    def __init__(self):
        self.track_trails = defaultdict(lambda: deque(maxlen=30))
        self.tracks = {}
        self.next_id = 1
    
    def update(self, detections):
        # Simple tracking - just add track IDs
        for i, det in enumerate(detections):
            det['track_id'] = i + 1
        return detections
    
    def get_last_detections(self):
        return []

class SimpleLineCounter:
    def __init__(self, line_id, point1, point2):
        self.line_id = line_id
        self.point1 = point1
        self.point2 = point2
        self.crossings = {'up': 0, 'down': 0}
    
    def update(self, detections):
        return []
    
    def get_statistics(self):
        return {
            'line_id': self.line_id,
            'crossings': self.crossings,
            'total': sum(self.crossings.values())
        }
    
    def reset_counts(self):
        self.crossings = {'up': 0, 'down': 0}


class RobustVehicleDetector:
    """Vehicle detector with robust ROI handling"""
    
    def __init__(self, model_path: str, device: str = "CPU", config: Optional[Dict] = None):
        self.device = device
        self.model_path = model_path
        
        # Default config
        self.input_shape = (416, 416)
        self.conf_threshold = 0.25
        self.nms_threshold = 0.5
        self.frame_skip = 2
        self.frame_counter = 0
        
        # Apply config if provided
        if config:
            self.input_shape = tuple(config.get('input_shape', (416, 416)))
            self.conf_threshold = config.get('conf_threshold', 0.25)
            self.nms_threshold = config.get('nms_threshold', 0.5)
            self.frame_skip = config.get('frame_skip', 2)
        
        # Mock model loading for testing
        self.compiled_model = None
        print(f"Mock detector initialized on {device}")
        
        # Vehicle classes
        self.vehicle_classes = {2: 'car', 3: 'motorcycle', 5: 'bus', 7: 'truck'}
        
        # Components
        self.tracker = SimpleTracker()
        
        # Performance monitoring
        self.fps_history = deque(maxlen=30)
        self.last_time = time.time()
        
        # ROI settings - ROBUST HANDLING
        self.roi_points = []
        self.roi_mask = None
        self.use_roi = False
        self.roi_valid = False
        self.current_frame_shape = None
        
        # Line counter settings
        self.counting_lines = []
        self.line_counters = []
        self.vehicle_counts = defaultdict(lambda: {'up': 0, 'down': 0})
    
    def set_roi_from_points(self, points: List[Tuple[int, int]], frame_shape: Tuple[int, int]):
        """ROBUST ROI creation with comprehensive error handling"""
        try:
            print(f"Setting ROI with {len(points)} points, frame shape: {frame_shape}")
            
            # Validate inputs
            if not points or len(points) < 3:
                print("❌ ROI needs at least 3 points")
                return False
            
            if not frame_shape or len(frame_shape) < 2:
                print("❌ Invalid frame shape")
                return False
            
            h, w = frame_shape[:2]
            if h <= 0 or w <= 0:
                print("❌ Invalid frame dimensions")
                return False
            
            # Store frame shape for validation
            self.current_frame_shape = (h, w)
            
            # Validate and clean points
            valid_points = []
            for point in points:
                try:
                    if isinstance(point, (list, tuple)) and len(point) >= 2:
                        x, y = int(point[0]), int(point[1])
                        # Clamp coordinates to frame bounds
                        x = max(0, min(x, w - 1))
                        y = max(0, min(y, h - 1))
                        valid_points.append((x, y))
                    else:
                        print(f"⚠️ Invalid point format: {point}")
                except (ValueError, TypeError) as e:
                    print(f"⚠️ Point conversion error: {e}")
                    continue
            
            if len(valid_points) < 3:
                print("❌ Not enough valid points after validation")
                return False
            
            # Remove duplicate points
            unique_points = []
            for point in valid_points:
                is_duplicate = False
                for existing in unique_points:
                    if abs(point[0] - existing[0]) < 3 and abs(point[1] - existing[1]) < 3:
                        is_duplicate = True
                        break
                if not is_duplicate:
                    unique_points.append(point)
            
            if len(unique_points) < 3:
                print("❌ Not enough unique points")
                return False
            
            # Create mask with error handling
            try:
                self.roi_mask = np.zeros((h, w), dtype=np.uint8)
                
                # Convert to numpy array with explicit dtype
                pts_array = np.array(unique_points, dtype=np.int32)
                pts_array = pts_array.reshape((-1, 1, 2))  # Reshape for cv2.fillPoly
                
                # Use cv2.fillPoly with error handling
                cv2.fillPoly(self.roi_mask, [pts_array], 255)
                
                # Validate mask was created properly
                if np.sum(self.roi_mask) == 0:
                    print("❌ ROI mask is empty")
                    self.roi_mask = None
                    return False
                
                # Success!
                self.roi_points = unique_points
                self.use_roi = True
                self.roi_valid = True
                
                print(f"✅ ROI created successfully with {len(unique_points)} points")
                print(f"   Mask area: {np.sum(self.roi_mask > 0)} pixels")
                return True
                
            except cv2.error as e:
                print(f"❌ OpenCV error in fillPoly: {e}")
                self.roi_mask = None
                self.use_roi = False
                self.roi_valid = False
                return False
            
            except Exception as e:
                print(f"❌ Unexpected error creating ROI mask: {e}")
                self.roi_mask = None
                self.use_roi = False
                self.roi_valid = False
                return False
                
        except Exception as e:
            print(f"❌ Critical error in set_roi_from_points: {e}")
            self.roi_mask = None
            self.use_roi = False
            self.roi_valid = False
            return False
    
    def add_counting_line(self, point1: Tuple[int, int], point2: Tuple[int, int]):
        """Add counting line with validation"""
        try:
            # Validate points
            if not point1 or not point2:
                print("❌ Invalid line points")
                return False
            
            x1, y1 = int(point1[0]), int(point1[1])
            x2, y2 = int(point2[0]), int(point2[1])
            
            # Check if points are different enough
            if abs(x1 - x2) < 5 and abs(y1 - y2) < 5:
                print("❌ Line points are too close together")
                return False
            
            line_id = len(self.counting_lines)
            self.counting_lines.append(((x1, y1), (x2, y2)))
            self.line_counters.append(SimpleLineCounter(line_id, (x1, y1), (x2, y2)))
            print(f"✅ Counting line {line_id} added: ({x1},{y1}) to ({x2},{y2})")
            return True
            
        except Exception as e:
            print(f"❌ Error adding counting line: {e}")
            return False
    
    def clear_roi_and_lines(self):
        """Clear all ROI and lines safely"""
        try:
            self.roi_points = []
            self.roi_mask = None
            self.use_roi = False
            self.roi_valid = False
            self.current_frame_shape = None
            self.counting_lines = []
            self.line_counters = []
            self.vehicle_counts = defaultdict(lambda: {'up': 0, 'down': 0})
            print("✅ All ROI and lines cleared")
        except Exception as e:
            print(f"❌ Error clearing ROI and lines: {e}")
    
    def detect_vehicles(self, frame: np.ndarray) -> Tuple[List[Dict], float]:
        """Mock detection for testing"""
        try:
            # Frame skipping
            self.frame_counter += 1
            if self.frame_counter % self.frame_skip != 0:
                return [], 0.0
            
            start_time = time.time()
            
            # Mock some detections for testing
            h, w = frame.shape[:2]
            mock_detections = [
                {
                    'bbox': [w//4, h//4, w//2, h//2],
                    'confidence': 0.85,
                    'class_id': 2,
                    'class_name': 'car',
                    'track_id': 1
                },
                {
                    'bbox': [w//2, h//3, 3*w//4, 2*h//3],
                    'confidence': 0.72,
                    'class_id': 7,
                    'class_name': 'truck',
                    'track_id': 2
                }
            ]
            
            # Filter by ROI if enabled
            if self.use_roi and self.roi_mask is not None and self.roi_valid:
                filtered_detections = []
                for det in mock_detections:
                    try:
                        x1, y1, x2, y2 = det['bbox']
                        center_x = (x1 + x2) // 2
                        center_y = (y1 + y2) // 2
                        
                        # Check bounds
                        if (0 <= center_y < self.roi_mask.shape[0] and 
                            0 <= center_x < self.roi_mask.shape[1]):
                            if self.roi_mask[center_y, center_x] > 0:
                                filtered_detections.append(det)
                    except Exception as e:
                        print(f"⚠️ ROI filtering error: {e}")
                        filtered_detections.append(det)  # Include if error
                
                mock_detections = filtered_detections
            
            # Update FPS
            processing_time = time.time() - start_time
            self.update_fps()
            
            return mock_detections, processing_time
            
        except Exception as e:
            print(f"❌ Detection error: {e}")
            return [], 0.0
    
    def update_fps(self):
        """Update FPS calculation"""
        current_time = time.time()
        self.fps_history.append(current_time - self.last_time)
        self.last_time = current_time
    
    def get_fps(self) -> float:
        """Get current FPS"""
        if len(self.fps_history) < 2:
            return 0.0
        return 1.0 / (np.mean(self.fps_history) + 1e-6)
    
    def get_statistics(self) -> Dict:
        """Get current statistics"""
        return {
            'fps': self.get_fps(),
            'frame_skip': self.frame_skip,
            'roi_enabled': self.use_roi and self.roi_valid,
            'line_count': len(self.counting_lines),
            'vehicle_counts': dict(self.vehicle_counts),
            'total_detections': sum(sum(counts.values()) for counts in self.vehicle_counts.values())
        }
    
    def apply_config(self, config: Dict):
        """Apply configuration"""
        self.input_shape = tuple(config.get('input_shape', (416, 416)))
        self.conf_threshold = config.get('conf_threshold', 0.25)
        self.nms_threshold = config.get('nms_threshold', 0.5)
        self.frame_skip = config.get('frame_skip', 2)


# For backward compatibility
OptimizedVehicleDetector = RobustVehicleDetector
